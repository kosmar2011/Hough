// ----------------------------------------------------------------------------
// SystemC Testbench Header
//
//    HLS version: 10.5a/871028 Production Release
//       HLS date: Tue Apr 14 07:55:32 PDT 2020
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4
//
//   Generated by: user2@edatools.ee.duth.gr
// Generated date: Wed Jul 07 20:35:03 EEST 2021
//
// ----------------------------------------------------------------------------
#ifdef CCS_SCVERIFY

// 
// -------------------------------------
// mc_testbench
// SCVerify mc_testbench SC_MODULE
// -------------------------------------
// 
#ifndef INCLUDED_MC_TESTBENCH_H
#define INCLUDED_MC_TESTBENCH_H


#ifndef SC_USE_STD_STRING
#define SC_USE_STD_STRING
#endif

#include "../../include/HoughHW.h"
#include "../../include/bmp_io.hpp"
#include "ccs_testbench.h"
#include <systemc.h>
#include <tlm.h>
#include <ac_int.h>
#include <ac_channel.h>
#include <mc_container_types.h>
#include <mc_typeconv.h>
#include <mc_transactors.h>
#include <mc_comparator.h>
#include <mc_end_of_testbench.h>
#include <vector>


class mc_testbench : public sc_module
{
public:
   // Module instance pointers
   mc_comparator< ac_int<11, false > , MaskPacket< 1, 11 > > *x1_comp;
   mc_comparator< ac_int<10, false > , MaskPacket< 1, 10 > > *y1_comp;
   mc_comparator< ac_int<11, false > , MaskPacket< 1, 11 > > *x2_comp;
   mc_comparator< ac_int<10, false > , MaskPacket< 1, 10 > > *y2_comp;
   
   // Interface Ports
   sc_in< bool > clk;
   sc_port< tlm::tlm_fifo_put_if< ac_int<8, false > > > ccs_data_in;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_data_in;
   sc_port< tlm::tlm_fifo_put_if< int > > ccs_sizecount_data_in;
   sc_port< tlm::tlm_fifo_put_if< ac_int<11, false > > > ccs_widthIn;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_widthIn;
   sc_port< tlm::tlm_fifo_put_if< ac_int<10, false > > > ccs_heightIn;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_heightIn;
   sc_port< tlm::tlm_fifo_get_if< ac_int<11, false > > > ccs_x1;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_x1;
   sc_port< tlm::tlm_fifo_get_if< ac_int<10, false > > > ccs_y1;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_y1;
   sc_port< tlm::tlm_fifo_get_if< ac_int<11, false > > > ccs_x2;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_x2;
   sc_port< tlm::tlm_fifo_get_if< ac_int<10, false > > > ccs_y2;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_y2;
   sc_in< bool > design_is_idle;
   sc_out< sc_logic > enable_stalls;
   sc_in< unsigned short > stall_coverage;
   
   // Named Objects
   
   // Data objects
   bool testbench_ended;
   int main_exit_code;
   bool atleast_one_active_input;
   sc_time last_event_time;
   sc_time last_event_time2;
   sc_signal< bool >                          cpp_testbench_active;
   sc_event testbench_end_event;
   sc_event reset_request_event;
   bool _checked_results;
   bool _failed;
   static mc_testbench* that;
   bool _channel_mismatch;
   unsigned int remaining_ccs_data_in;
   bool _capture_data_in;
   int data_in_capture_count;
   int data_in_iteration_count;
   void* data_in_pointer;
   bool data_in_pointer_set;
   bool _capture_widthIn;
   int widthIn_capture_count;
   int widthIn_iteration_count;
   bool _capture_heightIn;
   int heightIn_capture_count;
   int heightIn_iteration_count;
   unsigned int remaining_x1_golden;
   tlm::tlm_fifo< mc_golden_info< ac_int<11, false >, MaskPacket<1, 11> > > x1_golden;
   bool _capture_x1;
   int x1_capture_count;
   int x1_iteration_count;
   void* x1_pointer;
   bool x1_pointer_set;
   unsigned int remaining_y1_golden;
   tlm::tlm_fifo< mc_golden_info< ac_int<10, false >, MaskPacket<1, 10> > > y1_golden;
   bool _capture_y1;
   int y1_capture_count;
   int y1_iteration_count;
   void* y1_pointer;
   bool y1_pointer_set;
   unsigned int remaining_x2_golden;
   tlm::tlm_fifo< mc_golden_info< ac_int<11, false >, MaskPacket<1, 11> > > x2_golden;
   bool _capture_x2;
   int x2_capture_count;
   int x2_iteration_count;
   void* x2_pointer;
   bool x2_pointer_set;
   unsigned int remaining_y2_golden;
   tlm::tlm_fifo< mc_golden_info< ac_int<10, false >, MaskPacket<1, 10> > > y2_golden;
   bool _capture_y2;
   int y2_capture_count;
   int y2_iteration_count;
   void* y2_pointer;
   bool y2_pointer_set;
   int wait_cnt;
   sc_time previous_timestamp;
   sc_time average_period;
   unsigned int period_counter;
   bool calculate_period;
   
   // Declare processes (SC_METHOD and SC_THREAD)
   void wait_for_end();
   void run();
   
   // Constructor
   SC_HAS_PROCESS(mc_testbench);
   mc_testbench(
      const sc_module_name& name
   )
      : clk("clk")
      , ccs_data_in("ccs_data_in")
      , ccs_wait_ctrl_data_in("ccs_wait_ctrl_data_in")
      , ccs_sizecount_data_in("ccs_sizecount_data_in")
      , ccs_widthIn("ccs_widthIn")
      , ccs_wait_ctrl_widthIn("ccs_wait_ctrl_widthIn")
      , ccs_heightIn("ccs_heightIn")
      , ccs_wait_ctrl_heightIn("ccs_wait_ctrl_heightIn")
      , ccs_x1("ccs_x1")
      , ccs_wait_ctrl_x1("ccs_wait_ctrl_x1")
      , ccs_y1("ccs_y1")
      , ccs_wait_ctrl_y1("ccs_wait_ctrl_y1")
      , ccs_x2("ccs_x2")
      , ccs_wait_ctrl_x2("ccs_wait_ctrl_x2")
      , ccs_y2("ccs_y2")
      , ccs_wait_ctrl_y2("ccs_wait_ctrl_y2")
      , design_is_idle("design_is_idle")
      , enable_stalls("enable_stalls")
      , stall_coverage("stall_coverage")
      , cpp_testbench_active("cpp_testbench_active")
      , remaining_ccs_data_in(0)
      , remaining_x1_golden(0)
      , x1_golden("x1_golden",-1)
      , remaining_y1_golden(0)
      , y1_golden("y1_golden",-1)
      , remaining_x2_golden(0)
      , x2_golden("x2_golden",-1)
      , remaining_y2_golden(0)
      , y2_golden("y2_golden",-1)
   {
      // Instantiate other modules
      x1_comp = new mc_comparator< ac_int<11, false > , MaskPacket< 1, 11 > > (
         "x1_comp",
         "x1",
         1,
         0,
         1
      );
      x1_comp->data_in(ccs_x1);
      x1_comp->data_golden(x1_golden);
      
      y1_comp = new mc_comparator< ac_int<10, false > , MaskPacket< 1, 10 > > (
         "y1_comp",
         "y1",
         1,
         0,
         1
      );
      y1_comp->data_in(ccs_y1);
      y1_comp->data_golden(y1_golden);
      
      x2_comp = new mc_comparator< ac_int<11, false > , MaskPacket< 1, 11 > > (
         "x2_comp",
         "x2",
         1,
         0,
         1
      );
      x2_comp->data_in(ccs_x2);
      x2_comp->data_golden(x2_golden);
      
      y2_comp = new mc_comparator< ac_int<10, false > , MaskPacket< 1, 10 > > (
         "y2_comp",
         "y2",
         1,
         0,
         1
      );
      y2_comp->data_in(ccs_y2);
      y2_comp->data_golden(y2_golden);
      
      
      // Register processes
      SC_METHOD(wait_for_end);
      sensitive << clk.pos() << testbench_end_event;
      SC_THREAD(run);
      // Other constructor statements
      set_stack_size(64000000);
      _checked_results = false;
      that = this;
      testbench_ended = false;
      main_exit_code = 0;
      atleast_one_active_input = true;
      _failed = false;
      _capture_data_in = true;
      _capture_widthIn = true;
      _capture_heightIn = true;
      _capture_x1 = true;
      _capture_y1 = true;
      _capture_x2 = true;
      _capture_y2 = true;
      wait_cnt = 0;
      previous_timestamp = SC_ZERO_TIME;
      average_period = SC_ZERO_TIME;
      period_counter = 0;
      calculate_period = true;
   }
   
   ~mc_testbench()
   {
      delete x1_comp;
      x1_comp = 0;
      delete y1_comp;
      y1_comp = 0;
      delete x2_comp;
      x2_comp = 0;
      delete y2_comp;
      y2_comp = 0;
   }
   
   // C++ class functions
   public:
      static void wait_for_idle_sync() ;
   public:
      static void set_enable_stalls(bool flag) ;
   public:
      void reset_request() ;
   public:
      void capture_data_in( ac_channel<ac_int<8, false > > &data_in) ;
   public:
      void capture_widthIn( ac_int<11, false > &widthIn) ;
   public:
      void capture_heightIn( ac_int<10, false > &heightIn) ;
   public:
      void capture_x1( ac_channel<ac_int<11, false > > &x1) ;
   public:
      void capture_y1( ac_channel<ac_int<10, false > > &y1) ;
   public:
      void capture_x2( ac_channel<ac_int<11, false > > &x2) ;
   public:
      void capture_y2( ac_channel<ac_int<10, false > > &y2) ;
   protected:
      void wait_on_input_required() ;
   public:
      static void capture_IN( ac_channel<ac_int<8, false > > &data_in,  ac_int<11, false > &widthIn,  ac_int<10, false > &heightIn,  ac_channel<ac_int<11, false > > &x1,  ac_channel<ac_int<10, false > > &y1,  ac_channel<ac_int<11, false > > &x2,  ac_channel<ac_int<10, false > > &y2) ;
   public:
      static void capture_OUT( ac_channel<ac_int<8, false > > &data_in,  ac_int<11, false > &widthIn,  ac_int<10, false > &heightIn,  ac_channel<ac_int<11, false > > &x1,  ac_channel<ac_int<10, false > > &y1,  ac_channel<ac_int<11, false > > &x2,  ac_channel<ac_int<10, false > > &y2) ;
   public:
      static void exec_run( ac_channel<ac_int<8, false > > &data_in,  ac_int<11, false > &widthIn,  ac_int<10, false > &heightIn,  ac_channel<ac_int<11, false > > &x1,  ac_channel<ac_int<10, false > > &y1,  ac_channel<ac_int<11, false > > &x2,  ac_channel<ac_int<10, false > > &y2) ;
   protected:
      void start_of_simulation() ;
   protected:
      void end_of_simulation() ;
   public:
      void check_results() ;
   public:
      bool failed() ;
   public:
      void set_failed(bool fail) ;
};
#endif
#endif //CCS_SCVERIFY
